<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Builder Onboarding - Gloas Upgrade</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 417'%3E%3Cpath fill='%23343434' d='m127.961 0-2.795 9.5v275.668l2.795 2.79 127.962-75.638z'/%3E%3Cpath fill='%238C8C8C' d='M127.962 0 0 212.32l127.962 75.639V154.158z'/%3E%3Cpath fill='%233C3C3B' d='m127.961 312.187-1.575 1.92v98.199l1.575 4.601L256 236.587z'/%3E%3Cpath fill='%238C8C8C' d='M127.962 416.905v-104.72L0 236.585z'/%3E%3Cpath fill='%23141414' d='m127.961 287.958 127.96-75.637-127.96-58.162z'/%3E%3Cpath fill='%23393939' d='m.001 212.321 127.96 75.637V154.159z'/%3E%3C/svg%3E">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --border-color: #2a3f5f;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --heading-color: #e0a458;
            --link-color: #6db3f2;
            --success-color: #4ecca3;
            --warning-color: #ffc857;
            --error-color: #ff6b6b;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 2rem;
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        h2 {
            font-size: 1.25rem;
            color: var(--text-secondary);
            font-weight: 400;
            margin-bottom: 2rem;
        }
        h3 {
            font-size: 1.1rem;
            margin-bottom: 1rem;
            color: var(--heading-color);
        }
        .card {
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }
        .status-item {
            text-align: center;
            padding: 1rem;
            background-color: var(--bg-color);
            border-radius: 6px;
        }
        .status-label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }
        .status-value {
            font-size: 1.5rem;
            font-weight: 600;
            font-family: 'SF Mono', 'Consolas', monospace;
        }
        .status-value.loading {
            color: var(--text-secondary);
        }
        .status-value.safe {
            color: var(--success-color);
        }
        .status-value.warning {
            color: var(--warning-color);
        }
        .status-value.danger {
            color: var(--error-color);
        }
        .deposit-window {
            padding: 1rem;
            border-radius: 6px;
            text-align: center;
            font-size: 1.1rem;
            margin-top: 1rem;
        }
        .deposit-window.safe {
            background-color: rgba(78, 204, 163, 0.15);
            border: 1px solid var(--success-color);
        }
        .deposit-window.warning {
            background-color: rgba(255, 200, 87, 0.15);
            border: 1px solid var(--warning-color);
        }
        .deposit-window.danger {
            background-color: rgba(255, 107, 107, 0.15);
            border: 1px solid var(--error-color);
        }
        .deposit-window.unknown {
            background-color: rgba(139, 148, 158, 0.15);
            border: 1px solid var(--text-secondary);
        }
        code {
            background-color: rgba(110, 118, 129, 0.4);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 0.9em;
        }
        .steps {
            counter-reset: step;
        }
        .step {
            position: relative;
            padding-left: 2.5rem;
            margin-bottom: 1.5rem;
        }
        .step:last-child {
            margin-bottom: 0;
        }
        .step::before {
            counter-increment: step;
            content: counter(step);
            position: absolute;
            left: 0;
            top: 0;
            width: 1.75rem;
            height: 1.75rem;
            background-color: var(--heading-color);
            color: var(--bg-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.875rem;
        }
        .step h4 {
            margin-bottom: 0.5rem;
        }
        .step p {
            color: var(--text-secondary);
        }
        a {
            color: var(--link-color);
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .note {
            background-color: rgba(109, 179, 242, 0.1);
            border-left: 3px solid var(--link-color);
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.9rem;
        }
        .error-msg {
            color: var(--error-color);
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }
        .queue-info {
            margin-top: 1rem;
            padding: 1rem;
            background-color: var(--bg-color);
            border-radius: 6px;
            font-size: 0.9rem;
        }
        .queue-info-row {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
        }
        .queue-info-label {
            color: var(--text-secondary);
        }
        .queue-info-value {
            font-family: 'SF Mono', 'Consolas', monospace;
        }
        .update-info {
            margin-top: 1rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        footer {
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 0.875rem;
            text-align: center;
        }
        @media (max-width: 600px) {
            body {
                padding: 1rem;
            }
            .status-grid {
                grid-template-columns: 1fr;
            }
            .status-value {
                font-size: 1.25rem;
            }
            .queue-info-row {
                flex-direction: column;
                gap: 0.25rem;
            }
            .update-info {
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <h1>Builder Onboarding</h1>

    <div class="card">
        <h3>Network status</h3>
        <div class="status-grid">
            <div class="status-item">
                <div class="status-label">Current Slot</div>
                <div class="status-value loading" id="current-slot">--</div>
            </div>
            <div class="status-item">
                <div class="status-label">Upgrade Slot</div>
                <div class="status-value" id="fork-slot">TBD</div>
            </div>
            <div class="status-item">
                <div class="status-label">Current Epoch</div>
                <div class="status-value loading" id="current-epoch">--</div>
            </div>
            <div class="status-item">
                <div class="status-label">Upgrade Epoch</div>
                <div class="status-value" id="fork-epoch">TBD</div>
            </div>
        </div>
        <div class="deposit-window unknown" id="deposit-status">
            Loading...
        </div>
        <div class="queue-info" id="queue-info" style="display: none;">
            <div class="queue-info-row">
                <span class="queue-info-label">Churn limit per epoch:</span>
                <span class="queue-info-value" id="churn-limit">--</span>
            </div>
            <div class="queue-info-row">
                <span class="queue-info-label">Min queue for guarantee:</span>
                <span class="queue-info-value" id="min-queue-for-guarantee">--</span>
            </div>
            <div class="queue-info-row">
                <span class="queue-info-label">Pending deposit queue:</span>
                <span class="queue-info-value" id="queue-depth">--</span>
            </div>
            <div class="queue-info-row" id="queue-deficit-row" style="display: none;">
                <span class="queue-info-label">Difference:</span>
                <span class="queue-info-value" id="queue-deficit">--</span>
            </div>
            <div class="note" id="queue-explainer" style="display: none; margin-top: 0.75rem;">
                <strong>Note:</strong> When the pending deposit queue equals or exceeds the min
                queue for guarantee, a new deposit is guaranteed to be in the queue at the fork.
            </div>
        </div>
        <div class="update-info" id="update-info" style="display: none;">
            <span>Last updated: <span id="last-updated">--</span></span>
            <span>Next update in: <span id="next-update">--</span>s</span>
        </div>
        <div id="error-container"></div>
    </div>

    <div class="card">
        <h3>When to submit a builder deposit</h3>
        <p>To be onboarded as a builder at the <strong>first slot</strong> of the Gloas upgrade,
        the deposit must be in the <strong>pending deposits queue</strong> when the upgrade occurs.
        It is safe to deposit when the queue depth exceeds the minimum required for a guarantee
        (epochs until fork &times; 256 ETH/epoch).
    </p>

        <div class="note" style="border-left-color: var(--error-color); background-color: rgba(248, 81, 73, 0.1);">
            <strong>Warning:</strong> Depositing too early will result in the deposit being
            processed before the upgrade occurs. Since builders do not exist yet,
            a <code>0x03</code> deposit will be treated as a validator deposit
            and a <strong>validator will be created instead of a builder</strong>.
            This cannot be undone.
        </div>
    </div>

    <div class="card">
        <h3>How to onboard as a builder</h3>
        <div class="steps">
            <div class="step">
                <h4>Generate keys and deposit data</h4>
                <p>Use the <a href="https://github.com/ethstaker/ethstaker-deposit-cli" target="_blank">ethstaker-deposit-cli</a>
                to generate a new BLS keypair and deposit data. This must be separate from any existing validator keys.
                Withdrawal credentials must use the <code>0x03</code> prefix.</p>
            </div>
            <div class="step">
                <h4>Wait for the safe deposit window</h4>
                <p>Monitor this page and wait until it is safe to deposit.</p>
            </div>
            <div class="step">
                <h4>Submit deposit</h4>
                <p>Submit the deposit to the deposit contract. The deposit will be added to the pending
                    queue and processed during the Gloas upgrade.</p>
            </div>
        </div>
    </div>

    <script>
        const BEACON_API = 'https://beacon-api.ethspec.tools';
        const FORK_EPOCH_OVERRIDE = 423979;
        // Set to skip validators fetch
        const TOTAL_ACTIVE_BALANCE_OVERRIDE = 36000000000000000000n;

        // Minimum total active balance for max churn (256 ETH * 65536 = 16,777,216 ETH in gwei)
        const MIN_BALANCE_FOR_MAX_CHURN = 16777216000000000n;

        // Consensus layer constants (fetched from API)
        let FORK_EPOCH;
        let SLOTS_PER_EPOCH;
        let MAX_PER_EPOCH_ACTIVATION_EXIT_CHURN_LIMIT;

        async function fetchSpec() {
            const response = await fetch(`${BEACON_API}/eth/v1/config/spec`);
            if (!response.ok) throw new Error(`API returned ${response.status}`);
            const data = await response.json();
            const spec = data.data;

            SLOTS_PER_EPOCH = parseInt(spec.SLOTS_PER_EPOCH);
            MAX_PER_EPOCH_ACTIVATION_EXIT_CHURN_LIMIT = BigInt(spec.MAX_PER_EPOCH_ACTIVATION_EXIT_CHURN_LIMIT);

            // Use override if set, otherwise fetch from spec
            if (FORK_EPOCH_OVERRIDE !== null) {
                FORK_EPOCH = FORK_EPOCH_OVERRIDE;
            } else if (spec.GLOAS_FORK_EPOCH && spec.FAR_FUTURE_EPOCH) {
                const farFutureEpoch = BigInt(spec.FAR_FUTURE_EPOCH);
                const gloasForkEpoch = BigInt(spec.GLOAS_FORK_EPOCH);
                FORK_EPOCH = gloasForkEpoch >= farFutureEpoch ? null : Number(gloasForkEpoch);
            } else {
                FORK_EPOCH = null;
            }
        }

        async function fetchNetworkStatus() {
            const response = await fetch(`${BEACON_API}/eth/v1/beacon/headers/head`);
            if (!response.ok) throw new Error(`API returned ${response.status}`);
            const data = await response.json();
            const slot = parseInt(data.data.header.message.slot);
            return {
                current_slot: slot,
                current_epoch: Math.floor(slot / SLOTS_PER_EPOCH)
            };
        }

        // Cache for total active balance (only changes once per epoch)
        let cachedTotalActiveBalance = null;
        let cachedEpoch = null;

        async function fetchTotalActiveBalance(currentEpoch) {
            // Use override if set (avoids heavy validators fetch)
            if (TOTAL_ACTIVE_BALANCE_OVERRIDE !== null) {
                if (TOTAL_ACTIVE_BALANCE_OVERRIDE < MIN_BALANCE_FOR_MAX_CHURN) {
                    throw new Error(`Override balance ${TOTAL_ACTIVE_BALANCE_OVERRIDE} is below minimum ${MIN_BALANCE_FOR_MAX_CHURN} for max churn`);
                }
                return TOTAL_ACTIVE_BALANCE_OVERRIDE;
            }

            // Return cached value if same epoch
            if (cachedEpoch === currentEpoch && cachedTotalActiveBalance !== null) {
                return cachedTotalActiveBalance;
            }

            const validatorsResponse = await fetch(`${BEACON_API}/eth/v1/beacon/states/head/validators`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ statuses: ['active_ongoing'] })
            });
            if (!validatorsResponse.ok) throw new Error(`API returned ${validatorsResponse.status}`);
            const validatorsData = await validatorsResponse.json();
            cachedTotalActiveBalance = validatorsData.data.reduce(
                (sum, v) => sum + BigInt(v.validator.effective_balance), 0n
            );
            cachedEpoch = currentEpoch;

            // Assert total active balance is high enough for max churn limit
            if (cachedTotalActiveBalance < MIN_BALANCE_FOR_MAX_CHURN) {
                throw new Error(`Total active balance ${cachedTotalActiveBalance} is below minimum ${MIN_BALANCE_FOR_MAX_CHURN} for max churn`);
            }

            return cachedTotalActiveBalance;
        }

        async function fetchQueueStatus(currentEpoch) {
            // Verify total active balance is high enough for max churn assumption
            await fetchTotalActiveBalance(currentEpoch);

            // Fetch pending deposits queue
            const depositsResponse = await fetch(`${BEACON_API}/eth/v1/beacon/states/head/pending_deposits`);
            let pendingDepositsBalance = 0n;
            if (depositsResponse.ok) {
                const depositsData = await depositsResponse.json();
                pendingDepositsBalance = depositsData.data.reduce(
                    (sum, d) => sum + BigInt(d.amount), 0n
                );
            }

            return { pendingDepositsBalance };
        }

        function isGuaranteedSafe(currentEpoch, queueDepthGwei, churnLimitGwei) {
            if (FORK_EPOCH === null) return false;

            // Guaranteed safe if queue depth >= epochs_until_fork * churn_limit
            // This ensures deposit won't be processed even if no new deposits arrive
            const epochsUntilFork = BigInt(FORK_EPOCH - currentEpoch);
            const minQueueForGuarantee = epochsUntilFork * churnLimitGwei;
            return queueDepthGwei >= minQueueForGuarantee;
        }

        function formatGwei(gwei) {
            return BigInt(gwei).toLocaleString() + ' Gwei';
        }

        function formatTime(date) {
            return date.toLocaleTimeString('en-US', { hour12: false });
        }

        function updateUI(networkStatus, queueStatus) {
            const currentSlot = networkStatus.current_slot;
            const currentEpoch = networkStatus.current_epoch;

            // Update current slot and epoch
            document.getElementById('current-slot').textContent = currentSlot;
            document.getElementById('current-slot').classList.remove('loading');
            document.getElementById('current-epoch').textContent = currentEpoch;
            document.getElementById('current-epoch').classList.remove('loading');

            // Update fork slot and epoch
            if (FORK_EPOCH !== null) {
                document.getElementById('fork-epoch').textContent = FORK_EPOCH;
                document.getElementById('fork-slot').textContent = FORK_EPOCH * SLOTS_PER_EPOCH;
            }

            // Use hardcoded max churn limit (assertion verified total active balance is sufficient)
            const queueDepthGwei = queueStatus.pendingDepositsBalance;
            const churnLimitGwei = MAX_PER_EPOCH_ACTIVATION_EXIT_CHURN_LIMIT;
            const epochsUntilFork = FORK_EPOCH !== null ? FORK_EPOCH - currentEpoch : null;
            const minQueueForGuarantee = epochsUntilFork !== null ? BigInt(epochsUntilFork) * churnLimitGwei : null;

            // Show queue info
            document.getElementById('queue-info').style.display = 'block';
            document.getElementById('queue-depth').textContent = formatGwei(queueDepthGwei);
            document.getElementById('churn-limit').textContent = `${formatGwei(churnLimitGwei)}`;
            if (minQueueForGuarantee !== null) {
                document.getElementById('min-queue-for-guarantee').textContent = formatGwei(minQueueForGuarantee);
            } else {
                document.getElementById('min-queue-for-guarantee').textContent = '--';
            }

            const statusEl = document.getElementById('deposit-status');

            if (FORK_EPOCH === null) {
                statusEl.className = 'deposit-window warning';
                statusEl.innerHTML = `<strong>Do not deposit yet!</strong><br>
                    Upgrade epoch not yet scheduled`;
                return;
            }

            if (currentEpoch >= FORK_EPOCH) {
                statusEl.className = 'deposit-window safe';
                statusEl.innerHTML = `<strong>Safe to deposit!</strong><br>
                    The upgrade has occurred. Builder deposits are now processed normally.`;
                document.getElementById('queue-info').style.display = 'none';
            } else if (isGuaranteedSafe(currentEpoch, queueDepthGwei, churnLimitGwei)) {
                statusEl.className = 'deposit-window safe';
                statusEl.innerHTML = `<strong>Safe to deposit now!</strong><br>
                    Deposits are guaranteed to remain in the queue until the upgrade.`;
                document.getElementById('queue-deficit-row').style.display = 'none';
                document.getElementById('queue-explainer').style.display = 'block';
            } else {
                const queueDeficit = minQueueForGuarantee - queueDepthGwei;
                statusEl.className = 'deposit-window warning';
                statusEl.innerHTML = `<strong>Do not deposit yet!</strong><br>
                    Queue needs more to guarantee onboarding at the fork`;
                document.getElementById('queue-deficit-row').style.display = 'flex';
                document.getElementById('queue-deficit').textContent = formatGwei(queueDeficit);
                document.getElementById('queue-explainer').style.display = 'block';
            }
        }

        const SLOT_TIME = 12; // seconds
        let countdown = SLOT_TIME;
        let eventSource = null;

        function updateLastUpdated() {
            document.getElementById('last-updated').textContent = formatTime(new Date());
            document.getElementById('update-info').style.display = 'flex';
            countdown = SLOT_TIME;
        }

        function updateCountdown() {
            countdown--;
            if (countdown < 0) countdown = 0;
            document.getElementById('next-update').textContent = countdown;
        }

        async function fetchAndUpdate() {
            try {
                const networkStatus = await fetchNetworkStatus();
                const queueStatus = await fetchQueueStatus(networkStatus.current_epoch);
                updateUI(networkStatus, queueStatus);
                updateLastUpdated();
            } catch (error) {
                console.error('Failed to fetch:', error);
                throw error;
            }
        }

        function setupEventSource() {
            eventSource = new EventSource(`${BEACON_API}/eth/v1/events?topics=head`);

            eventSource.addEventListener('head', async (event) => {
                try {
                    await fetchAndUpdate();
                } catch (error) {
                    console.error('Failed to update on head event:', error);
                }
            });

            eventSource.onerror = (error) => {
                console.error('EventSource error:', error);
                eventSource.close();
                // Reconnect after 5 seconds
                setTimeout(setupEventSource, 5000);
            };
        }

        async function init() {
            try {
                // Fetch consensus layer constants first
                await fetchSpec();

                await fetchAndUpdate();

                // Subscribe to head events via SSE
                setupEventSource();

                // Update countdown every second
                setInterval(updateCountdown, 1000);
            } catch (error) {
                console.error('Failed to initialize:', error);
            }
        }

        init();
    </script>
</body>
</html>
